---
layout: projbase
---



<div class="loader"></div>

<script type="text/javascript">
  var faded = false;

  var startFadeOut = function() {
    if (!faded) {
      faded = true;
      $(".loader").fadeOut("slow");
    }
  };

  $(window).load(startFadeOut);
  setTimeout(startFadeOut, 2500);

  $(document).ready(function(){
    $(".snippet-carousel").slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      fade: false,
      arrows: true,
      asNavFor: ".snippet-nav-carousel"
    });
    $(".snippet-nav-carousel").slick({
      slidesToShow: 7,
      slidesToScroll: 1,
      arrows: true,
      centerMode: true,
      focusOnSelect: true,
      asNavFor: ".snippet-carousel"
    });

    $("#event-driven-video").on("canplaythrough", function() {
      this.play();
    });
    $("#first-class-video").on("canplaythrough", function() {
      this.play();
    });
    $("#declarative-video").on("canplaythrough", function() {
      this.play();
    });
    $("#concurrent-video").on("canplaythrough", function() {
      this.play();
    });
    $("#reactive-collections-video").on("canplaythrough", function() {
      this.play();
    });
    $("#gc-friendly-video").on("canplaythrough", function() {
      this.play();
    });
  });
</script>

<div>
  <script src="/resources/js/reactress-banner.js"></script>
  <div class="banner">
    <div id="bannercenter" class="bannercenter">
      <span class="bannerdescription">
        Foundational framework <br/>for distributed computing
      </span>
      <img src="/resources/images/reactress-banner.jpg"/>
      <div class="bannerlinks">
        <a href="https://github.com/reactors-io/reactors"><img class="bannerlink" id="link-github" src="/resources/images/icons/github7-gray.png"/></a>
        <a href="https://groups.google.com/forum/#!forum/reactors-io"><img class="bannerlink" id="link-groups" src="/resources/images/icons/mail8-gray.png"/></a>
        <a href="https://twitter.com/reactors_io"><img class="bannerlink" id="link-twitter" src="/resources/images/icons/twitter4-gray.png"/></a>
      </div>
    </div>
  </div>

  <div class="bannerdivider">
  </div>

  <div class="bannerlogoholder">
    <div class="bannerlogo">
      <img src="/resources/images/reactress-gradient.png"/>
    </div>
    <div class="bl bl-download">
      <a href="/download/">
        <img src="/resources/images/icons/download61-gray.png" height="14px"/>
        Download latest version
      </a>
      <div class="right-edge"></div>
      <div class="edge-cover" style="left: 200px;"></div>
      <div class="edge-cover-right" style="left: 230px;"></div>
    </div>
    <div class="bl bl-build-status">
      <a href="https://travis-ci.org/reactors-io/reactors">
        <img src="/resources/images/icons/cogs3-gray.png" height="14px"/>
        <img class="buildstatus"
          src="https://travis-ci.org/reactors-io/reactors.svg?branch=master"
          onError="this.src='/resources/images/passing.svg';" />
      </a>
      <div class="right-edge"></div>
      <div class="edge-cover"></div>
      <div class="edge-cover-right"></div>
    </div>
    <div class="bl bl-tutorial">
      <a href="http://reactors.io/tutorialdocs/reactors/">
        Getting started guide
        <img src="/resources/images/icons/graduation20-gray.png" height="14px"/>
      </a>
      <div class="left-edge"></div>
      <div class="edge-cover" style="left: -30px;"></div>
      <div class="edge-cover-right" style="left: -35px;"></div>
    </div>
    <div class="bl bl-docs">
      <a href="https://www.javadoc.io/doc/io.reactors/reactors-core_2.11/{{ site.reactors_version }}">
        API docs
        <img src="/resources/images/icons/open161-gray.png" height="14px"/>
      </a>
      <div class="left-edge"></div>
      <div class="edge-cover" style="left: -30px;"></div>
      <div class="edge-cover-right" style="left: -35px;"></div>
    </div>
  </div>

  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>
  <br/>

  <div id="main" class="container_16">

    <div class="grid_1">
      &nbsp;
    </div>
    <div class="grid_7">
      <span class="punchline">
        Actors done right
      </span>
      <br/>
      <span class="subpunchline">
        Reactors.IO fuses
        the best parts of
        <span class="subpunchline-frp">functional reactive programming</span>
        and the
        <span class="subpunchline-actor">actor model</span>
      </span>
      <br/>
      <br/>
      <div class="frontends">
        <img height="48px" src="/resources/images/scala-grey.png"/>
        &nbsp; &nbsp;
        <img height="48px" src="/resources/images/scala-js-grey.png"/>
        <img height="48px" src="/resources/images/java-grey.png"/>
      </div>
    </div>
    <div class="grid_6">
      <div class="text-snippet">
        <p>
          Reactors.IO is a framework
          for building distributed systems.
          It combines the strengths of functional reactive programming
          and classical actor systems to provide
          a next generation foundation for distributed computing.
        </p>

        <p>
          Primarily targetting the JVM,
          the Reactors framework has bindings
          for both Java and Scala.
          More coming soon!
        </p>

        <p>
          To learn more,
          see the quick tour of features below,
          take a look at the <a href="/learn/">documentation section</a>
          or check out our
          <a href="http://reactors.io/tutorialdocs/reactors/">Getting Started Guide</a>.
        </p>
      </div>
    </div>
    <div class="grid_2">
      &nbsp;
    </div>

    <div class="grid_16 main-description">
      <br/>
      <br/>
      <br/>
      <hr/>
    </div>

    <div class="grid_16">
      <div class="snippet-carousel">
        <div class="container_16">
          <div class="grid_5">
            <h2 class="story-header">Event-driven</h2>
            <p>
              Event-driven architecture
              serves as the basis for
              distributed computing.
            </p>

            <p>
              Events are encapsulated inside entities called event streams.
              After an event arrives,
              it gets forwarded to the observers
              of that event stream.
            </p>
            <div class="snippet-animation">
              <video id="event-driven-video" width="200" loop autoplay="autoplay">
                <source src="/resources/images/animations/event-driven.mp4" type="video/mp4">
              </video>
            </div>
          </div>
          <div class="grid_10">
            <div class="main-code">
<pre class="lang-scala"><code>// Create an event stream.
val events = new Events.Emitter[Int]

// Compute sum of events.
var sum = 0
events.onEvent { x => sum += x }

// Count the events.
var count = 0
events.on { count += 1 }

// When done, compute the average.
var avg = 0
events.onDone { avg = sum / count }

// Emit a few events and close the event stream.
for (i <- List(1, 2, 6)) events.react(i)
events.unreact()
</code></pre>
            </div>
          </div>
        </div>
        <div class="container_16">
          <div class="grid_5">
            <h2 class="story-header">First-class</h2>
            <p>
              First-class events streams and signals
              allow a better separation of concerns.
            </p>
            <p>
              Components are expressed as
              event stream operations,
              which can be packaged into modules,
              and later reused or further composed.
            </p>
            <div class="snippet-animation">
              <video id="first-class-video" width="200" loop autoplay="autoplay">
                <source src="/resources/images/animations/first-class.mp4" type="video/mp4">
              </video>
            </div>
          </div>
          <div class="grid_10">
            <div class="main-code">
<pre class="lang-scala"><code>// Define digital circuits.
def and(a: Signal[Boolean], b: Signal[Boolean]) =
  (a zip b)(_ && _)
def xor(a: Signal[Boolean], b: Signal[Boolean]) =
  (a zip b)(_ ^ _)
def halfAdder(a: Signal[Boolean], b: Signal[Boolean]) =
  (xor(a, b), and(a, b))
def probe(name: String, r: Events[Boolean]) =
  r.onEvent(v => println(s"$name: $v"))

// Simulate a half-adder.
val inputA = RCell(false)
val inputB = RCell(false)
val (sum, carry) = halfAdder(inputA, inputB)
probe("sum", sum)
probe("carry", carry)
inputA := true
inputB := true
</code></pre>
            </div>
          </div>
        </div>
        <div class="container_16">
          <div class="grid_5">
            <h2 class="story-header">Declarative</h2>
            <p>
              Declarative programming style based on functional
              composition produces programs that are more concise, and
              easy to understand.
            </p>
            <p>
              An event stream is treated similarly
              to a Scala collection or Java Stream -
              plethora of functional combinators
              unlock a rich set of behaviors.
            </p>
            <div class="snippet-animation">
              <video id="declarative-video" width="200" loop autoplay="autoplay">
                <source src="/resources/images/animations/declarative.mp4" type="video/mp4">
              </video>
            </div>
          </div>
          <div class="grid_10">
            <div class="main-code">
<pre class="lang-scala"><code>// Stores a set of keys across distributed shards.
class DistributedHashTable[K](val channels: Set[Channel[K]]) {
  val sharding = (k: K) => k.## % channels.size

  // Group events into shards, batch them, and send to channels.
  val insertions = new Events.Emitter[K]
  insertions.groupBy(sharding)
    .map {
      case (k, events) => events.batch(4).map((k, _))
    }
    .flatten
    .onMatch {
      case (k, batch) => channels(k) ! batch
    }

  // Send the key to the insertions stream.
  def insert(k: K): Unit = insertions.react(k)
}
</code></pre>
            </div>
          </div>
        </div>
        <div class="container_16">
          <div class="grid_5">
            <h2 class="story-header">Concurrent</h2>
            <p>
              Concurrency is achieved by separating
              event propagations into entities called reactors.
              Reactors communicate through typed channels.
            </p>
            <div class="snippet-animation">
              <video id="concurrent-video" width="200" loop autoplay="autoplay">
                <source src="/resources/images/animations/concurrent.mp4" type="video/mp4">
              </video>
            </div>
          </div>
          <div class="grid_10">
            <div class="main-code">
<pre class="lang-scala"><code>// The DNS server channel is a globally available server channel
// that responds to requests for a channel with the specified name.
val dns: Server[Name, Channel[String]]

// Reactor that sends a set of keys to a shard.
class DhtClient(val shard: String, val keys: Set[String])
extends Reactor[Unit] {
  // Request the channel to the shard from the DNS server.
  (dns ? shard) onEvent { dht =>
    // Use the channel to send all the keys.
    for (k <- keys) dht ! k
  }
}

// Start the client reactor.
val shard = "shard04"
val keys = Set("key1", "key2", "key3")
system.spawn(Proto[DhtClient](shard, keys))
</code></pre>
            </div>
          </div>
        </div>
        <div class="container_16">
          <div class="grid_5">
            <h2 class="story-header">Reactive collections</h2>
            <p>
              Incremental data structures produce events when they are mutated.
              Clients can selectively track incremental changes.
            </p>
            <div class="snippet-animation">
              <video id="reactive-collections-video" width="200" loop autoplay="autoplay">
                <source src="/resources/images/animations/reactive-collections.mp4" type="video/mp4">
              </video>
            </div>
          </div>
          <div class="grid_10">
            <div class="main-code">
<pre class="lang-scala"><code>// Create a reactive map with channels.
val channels = RHashMap[String, Channel[String]]

// When any channel is inserted, send it a greeting message.
channels.inserts onEvent { k =>
  channels(k) ! "ping"
}

// When a master channel is inserted, register as worker.
channels.at("master") onEvent { ch =>
  ch ! "worker"
}

// Add a worker channel.
map("worker") = workerChannel

// Add a master channel.
map("master") = masterChannel
</code></pre>
            </div>
          </div>
        </div>
        <div class="container_16">
          <div class="grid_5">
            <h2 class="story-header">GC-friendly</h2>
            <p>
              Eliminates boxing for primitive values such as integers
              and doubles.
              GC pauses were never shorter!
            </p>
            <div class="snippet-animation">
              <div class="snippet-animation-frame paper-frame">
                <video style="display: block;" id="gc-friendly-video" width="220px" loop autoplay="autoplay">
                  <source src="/resources/images/animations/gc-friendly.mp4" type="video/mp4">
                </video>
              </div>
            </div>
          </div>
          <div class="grid_10">
            <div class="main-code">
<pre class="lang-scala"><code>// No boxing!
class Counter extends Reactor[Int] {
  var count = 0
  main.events.on(count += 1)
}

// Start a counter reactor instance.
val ch = system.spawn(Proto[Counter])

// Forward cell values to the counter.
val cell = RCell(0)
cell onEvent {
  x => ch ! x
}
cell := 1
cell := 2
cell := 3
cell := 4
</code></pre>
            </div>
          </div>
        </div>
        </div>
      </div>

      <br/>

      <div class="snippet-nav-carousel">
        <div>
          <div class="main-items-icon">
            <img src="/resources/images/icons/dark18.png"/>
          </div>
        </div>
        <div>
          <div class="main-items-icon">
            <img src="/resources/images/icons/rank-1.png"/>
          </div>
        </div>
        <div>
          <div class="main-items-icon">
            <img src="/resources/images/icons/view2.png"/>
          </div>
        </div>
        <div>
          <div class="main-items-icon">
            <img src="/resources/images/icons/crossed-arrows.png"/>
          </div>
        </div>
        <div>
          <div class="main-items-icon">
            <img src="/resources/images/icons/database7.png"/>
          </div>
        </div>
        <div>
          <div class="main-items-icon">
            <img src="/resources/images/icons/triangular42.png"/>
          </div>
        </div>
      </div>
    </div>

    <div class="container_16">
      <div class="grid_16 main-description">
        <hr/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
      </div>

      <div class="grid_6">
        <h2 class="story-header">
          And does all this work?
        </h2>
        <p>
          It sure does.
        </p>
        <p>
          Reactors.IO was used
          to implement a real-time 3D engine prototype.
          The reactive nature of a game engine
          was an excellent fit for Reactors.IO,
          both from the user interface and
          from the game simulation standpoint.
        </p>
        <p>
          The Reactors.IO implementation ensures
          low GC overheads and good throughput.
          The engine delivers a steady, high frame rate (>100FPS),
          with low latency.
        </p>
      </div>

      <div class="grid_10">
        <div class="snippet-animation-frame paper-frame">
          <iframe style="display: block;" width="640" height="400" src="https://www.youtube.com/embed/ebbrAHNsexc?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>
        </div>
      </div>

      <div class="grid_16 main-description">
        <br/>
        <br/>
      </div>
    </div>

    <br/>
    <br/>
    <br/>
    <br/>
  </div>
</div>












